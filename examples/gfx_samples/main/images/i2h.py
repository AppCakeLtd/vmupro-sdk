#
#  Convert a black and white bitmap to a bit packed format suitable for the OLED
#
# Note: b&w, not monochrome - just has to have 0,0,0 and 255,255,255 pixels
#
#
# Usage:
#
#   Individual file:
#
#     py i2h.py thing.bmp
#
#   Whole folder:
#
#     py i2h.py .
#


import os
import sys
import pyperclip
from PIL import Image
from math import ceil
from pathlib import Path

# Add as an *argv?
thresh = 128


def GetHeaderPath():

    dir = os.path.dirname(__file__)
    # iconsPath = os.path.join(dir, "..", "components", "icons")
    iconsPath = os.path.realpath(dir)

    return iconsPath


def SaveFile(stem, inBytes):

    iconsPath = GetHeaderPath()

    outPath = ""

    outPath = os.path.join(iconsPath, (stem + ".raw"))

    outFile = open(outPath, "wb")

    outFile.write(bytes(inBytes))

    outFile.close


def GenerateHeaderAndMakeFile(stems):
    # type: (list[tuple[str,int,int,int,int]]) -> None
    # it's like (stem, length, width, height, snapheight)

    iconsPath = GetHeaderPath()
    print("Using icons path {}".format(iconsPath))

    #
    # CMke stuff
    #

    # cPath = os.path.join(iconsPath, "CMakeLists.txt")

    # cSrc = 'idf_component_register(\n'
    # cSrc += 'INCLUDE_DIRS "."\n'
    # cSrc += 'EMBED_FILES\n'
    # cSrc += '<replaceme>\n'
    # cSrc += ')\n'

    # stemStrings = ""

    # for thing, thingLength, thingWidth, thingHeight, thingSnapHeight in stems:
    #     stemStrings += '    "' + thing + '.raw"\n'

    # cSrcOut = cSrc.replace("<replaceme>", stemStrings)

    # cFile = open(cPath, "w")
    # cFile.write(cSrcOut)
    # cFile.close()

    headerPath = os.path.join(iconsPath, "icons.h")

    hSrc = """
    // This file is auto-generated by i2h.py and should not be modified manually!
    // Note: temporary transitional copies in old style and new Img style

    #pragma once
    #include <stdio.h>
    #include <stdint.h>

    // height not required but reduces calcs required
    // for image positioning
    typedef struct {
        uint8_t* data;
        uint32_t size; // in bytes (so w * h * uint16_t for raw images)
        uint32_t width;
        uint32_t height;        
    } Img;

    """

    typeString = "raw"

    hSrc += "\n    // Start with protos\n\n"

    for thing, thingLength, thingWidth, thingHeight, thingBytes in stems:

        
        baseString = '    uint8_t {}_{}_start[];'.format(
            thing, typeString)

        hSrc += baseString
        hSrc += "\n"

        sizeString = '    const uint32_t {}_{}_size = {};'.format(
            thing, typeString, thingLength)
        hSrc += sizeString
        hSrc += "\n"

        widthString = '    const uint32_t {}_{}_width = {};'.format(
            thing, typeString, thingWidth)
        hSrc += widthString
        hSrc += "\n"

        imgString = '    const Img img_{}_{} = {{ {}_{}_start, {}, {}, {} }};'.format(
            thing, typeString, thing, typeString, thingLength, thingWidth, thingHeight)
        hSrc += imgString
        hSrc += "\n"

        # wee space would be nice
        hSrc += "\n"

    # then put the actual data at the bottom

    for thing, thingLength, thingWidth, thingHeight, thingBytes in stems:
        
        baseString = '    uint8_t {}_{}_start[] ='.format(
            thing, typeString)
        
        hSrc += baseString
        hSrc += """{"""
        hSrc += "\n"

        hex = ', '.join(f'0x{b:02X}' for b in thingBytes)
        hSrc += hex

        hSrc += """};"""
        hSrc += "\n"
        hSrc += "\n"
        

    hFile = open(headerPath, "w")
    hFile.write(hSrc)
    hFile.close()

# Remember it's inverted
# E.g. black pixel = white on the OLED


def GetThresh(rgb):
    global thresh
    combined = (rgb[0]+rgb[1]+rgb[2])/3
    return 1 if combined < thresh else 0


def ProcessFile(fName):
    # type: (str) -> tuple[str, int, int, int, bytes]

    im = Image.open(fName)
    pix = im.load()

    width = im.size[0]
    height = im.size[1]

    numPixels = width * height

    bytes = []

    reverseBitOrder = 1

    # activeByte = 0
    # bitPos = 7 if reverseBitOrder else 0

    for row in range(height):
        for col in range(width):

            activeByte = 0

            x = col
            y = row

            if (y < height):
                rgb = pix[x, y]
            else:
                rgb = (0, 0, 0)

            # Convert the RGB value to a 16-bit 565 value
            red = (rgb[0] >> 3) & 0x1F  # 5 bits for red
            green = (rgb[1] >> 2) & 0x3F  # 6 bits for green
            blue = (rgb[2] >> 3) & 0x1F  # 5 bits for blue

            # Pack the RGB 565 into 16 bits
            pixVal = (red << 11) | (green << 5) | blue

            # Append the high and low bytes of the 16-bit value
            bytes.append((pixVal >> 8) & 0xFF)
            bytes.append(pixVal & 0xFF)

    stem = Path(fName).stem

    # SaveFile(stem, bytes)

    byteLen = len(bytes)
    return (stem, byteLen, width, height, bytes)


if len(sys.argv) < 2 or sys.argv[1] == ".":

    dir = os.path.dirname(__file__)
    bmps = Path(dir).rglob("*.bmp")
    psds = Path(dir).rglob("*.psd")
    jpgs = Path(dir).rglob("*.jpg")
    pngs = Path(dir).rglob("*.png")
    bitmaps = [thing for thing in bmps] + [thing for thing in psds] + \
        [thing for thing in jpgs] + [thing for thing in pngs]

    stemsAndLengths = []

    for fName in bitmaps:

        if "_exclude_" in str(fName):
            continue

        stem, stemLength, width, height, stemBytes = ProcessFile(fName)

        stemsAndLengths.append(
            (stem, stemLength, width, height, stemBytes))

        # don't spam the console with bytes, lol
        printable = (stem, stemLength, width, height)
        print("Added: {}".format(printable))
        print("Byte length is {}".format(len(stemBytes)))

    GenerateHeaderAndMakeFile(stemsAndLengths)

else:

    fName = os.path.join(dir, sys.argv[1])

    if not os.path.exists(fName):
        raise Exception("can't find the file: {}".format(fName))

    ProcessFile(fName, False)
