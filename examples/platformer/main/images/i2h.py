#
#  Convert a black and white bitmap to a bit packed format suitable for the OLED
#
# Note: b&w, not monochrome - just has to have 0,0,0 and 255,255,255 pixels
#
#
# Usage:
#
#   Individual file:
#
#     py i2h.py thing.bmp
#
#   Whole folder:
#
#     py i2h.py .
#


import os
import sys
import pyperclip
import struct
from PIL import Image
from math import ceil
from pathlib import Path
from dataclasses import dataclass

# Add as an *argv?
thresh = 128

# used to pass image data back and forth
@dataclass
class ImgInfo:
    name: str    
    compressedLength: int
    rawLength: int
    rawChecksum : int
    width: int
    height: int
    compressedBytes: bytes


def GetHeaderPath():

    dir = os.path.dirname(__file__)
    # iconsPath = os.path.join(dir, "..", "components", "icons")
    iconsPath = os.path.realpath(dir)

    return iconsPath


def SaveFile(stem, inBytes, inExt):

    iconsPath = GetHeaderPath()

    outPath = ""

    outPath = os.path.join(iconsPath, (stem + inExt))

    outFile = open(outPath, "wb")

    outFile.write(bytes(inBytes))

    outFile.close


def GenerateHeaderAndMakeFile(stems):
    # type: (list[ImgInfo]) -> None
    
    iconsPath = GetHeaderPath()
    print("Using icons path {}".format(iconsPath))

    headerPath = os.path.join(iconsPath, "images.h")

    hSrc = """
    // This file is auto-generated by i2h.py and should not be modified manually!
    
    #pragma once
    #include <stdio.h>
    #include <stdint.h>

    // height not required but reduces calcs required
    // for image positioning
    typedef struct {
        const char * name;
        const uint32_t index;
        const uint8_t* compressedData;
        const uint32_t compressedSize;
        const uint32_t rawSize; // in bytes (so w * h * uint16_t for raw images)        
        const uint32_t rawChecksum;
        const uint32_t width;
        const uint32_t height;        
    } Img;

    """

    # TODO: well worth changing now that it's not raw
    typeString = "raw"

    index = 0
    for info in stems:

        baseString = '    const uint8_t {}_{}_start[];'.format(
            info.name, typeString)

        hSrc += baseString
        hSrc += "\n"

        # best break this up for readability        
        hSrc += f"    const Img img_{info.name}_{typeString} = {{ "        
        hSrc += f"\"{info.name}\", "
        hSrc += f"{index}, "
        hSrc += f"{info.name}_{typeString}_start, "
        hSrc += f"{info.compressedLength}, "
        hSrc += f"{info.rawLength}, "
        hSrc += f"{hex(info.rawChecksum)}, "
        hSrc += f"{info.width}, "
        hSrc += f"{info.height}"
        hSrc += f"}};"
        hSrc += "\n"

        # wee space would be nice
        hSrc += "\n"

        index+=1;

    # make a list of all known images
    # so we can unpack them
    #for info in stems:

    hSrc += "\n\n\n"
    hSrc += "// force a compile time const without #define\n"
    hSrc += f"enum{{ allImagesLength = {len(stems)}}};\n"    
    hSrc += "const Img * allImages[] = {\n"

    # Generate a little pointer list to make it easier to decompress everything
    for info in stems:
        # TODO: i don't like the duplication here
        imgString = "img_{}_{}".format(info.name, typeString)
        
        hSrc+= "  &" + imgString + ",\n"

    hSrc += "};"
    hSrc += "\n\n\n"

    # then put the actual hex data at the bottom
    for info in stems:
        
        baseString = '    const uint8_t {}_{}_start[] __attribute__((aligned(4))) ='.format(
            info.name, typeString)
        
        hSrc += baseString
        hSrc += """{"""
        hSrc += "\n"

        hexVal = ', '.join(f'0x{b:02X}' for b in info.compressedBytes)
        hSrc += hexVal

        hSrc += """};"""
        hSrc += "\n"
        hSrc += "\n"
        

    hFile = open(headerPath, "w")
    hFile.write(hSrc)
    hFile.close()


# Read in 16-bit 565 pairs since they'll
# compress better than individual bytes
# for blocks of most colour
def RLE16BitEncode(inData):
    # type: (bytes) -> bytes

    # read out a 16bit 565 value from 2 bytes
    def Get16(pos):        
        hiByte = inData[pos*2]
        loByte = inData[(pos*2) +1]
        byteVal = loByte << 8 | hiByte
        return byteVal
    
    numPixels = len(inData) /2

    rVal = bytearray()

    i = 0
    while i < numPixels:

        runLength = 1
        
        # determine the run length
        # stop at 255
        currentVal = Get16(i)
        while True:
            if  i + runLength >= numPixels :
                break
            if  currentVal != Get16(i+runLength) :
                break
            if runLength >= 255:
                break;
            runLength += 1

        rVal.append(runLength)
        
        u16 = struct.pack('<H', currentVal)
        rVal.extend( u16 )

        i += runLength
    return rVal

# included for verification
def RLE16BitDecode(inData):
    # type: (bytes) -> bytes

    rVal = bytearray()
    i = 0
    while i < len(inData):
        runLength = inData[i]

        u16 = inData[i+2] << 8 | inData[i+1]
        u16 = struct.pack('<H', u16)

        for run in range(runLength):
            rVal.extend(u16)

        i += 3
    return bytes(rVal)

def ChecksumDJB2(bytes):
    # type (bytes) -> int

    returnVal = 5381;
    for i in range(len(bytes)):
        returnVal = (returnVal<<5) + returnVal + bytes[i]
        returnVal = returnVal &0xFFFFFFFF

    return returnVal


def ProcessFile(fName):
    # type: (str) -> ImgInfo

    im = Image.open(fName)
    pix = im.load()

    width = im.size[0]
    height = im.size[1]

    numPixels = width * height

    bytes = []

    reverseBitOrder = 1

    # activeByte = 0
    # bitPos = 7 if reverseBitOrder else 0

    for row in range(height):
        for col in range(width):

            activeByte = 0

            x = col
            y = row

            if (y < height):
                rgb = pix[x, y]
            else:
                rgb = (0, 0, 0)

            # Convert the RGB value to a 16-bit 565 value
            red = (rgb[0] >> 3) & 0x1F  # 5 bits for red
            green = (rgb[1] >> 2) & 0x3F  # 6 bits for green
            blue = (rgb[2] >> 3) & 0x1F  # 5 bits for blue

            # Pack the RGB 565 into 16 bits
            pixVal = (red << 11) | (green << 5) | blue

            # Append the high and low bytes of the 16-bit value
            bytes.append((pixVal >> 8) & 0xFF)
            bytes.append(pixVal & 0xFF)

    stem = Path(fName).stem

    rawLength = len(bytes)

    compressedBytes = RLE16BitEncode(bytes)
    # Debug: save .raw file to examine
    #SaveFile(stem, bytes, ".raw")
    #SaveFile(stem, compressedBytes, ".rle")

    # Validate the decompression
    checkBytes = RLE16BitDecode(compressedBytes)

    for i in range(rawLength):
        if bytes[i] != checkBytes[i]:
            errorVal = f"Decompression failed at pos {i} of {rawLength}"
            raise Exception(errorVal)
      
    compressedLength = len(compressedBytes)
    print("Compressed from {} to {} bytes".format(rawLength, compressedLength))

    rawChecksum = ChecksumDJB2(bytes)
    print(f"Checksum: {hex(rawChecksum)}")
    
    # Debug: switch the last param to regular bytes for raw testing
    return ImgInfo(stem, compressedLength, rawLength, rawChecksum, width, height, compressedBytes)


if len(sys.argv) < 2 or sys.argv[1] == ".":

    dir = os.path.dirname(__file__)
    bmps = Path(dir).rglob("*.bmp")
    psds = Path(dir).rglob("*.psd")
    jpgs = Path(dir).rglob("*.jpg")
    pngs = Path(dir).rglob("*.png")
    bitmaps = [thing for thing in bmps] + [thing for thing in psds] + \
        [thing for thing in jpgs] + [thing for thing in pngs]

    stemsAndLengths = []

    for fName in bitmaps:

        if "_exclude_" in str(fName):
            continue
        
        info = ProcessFile(fName)

        stemsAndLengths.append(info)

        # don't spam the console with bytes, lol        
        printable = (info.name, info.compressedLength, info.rawLength, info.rawChecksum, info.width, info.height)
        print("Added: {}".format(printable))

    GenerateHeaderAndMakeFile(stemsAndLengths)

else:

    fName = os.path.join(dir, sys.argv[1])

    if not os.path.exists(fName):
        raise Exception("can't find the file: {}".format(fName))

    ProcessFile(fName, False)
