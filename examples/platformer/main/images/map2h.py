import os
import struct
from dataclasses import dataclass

@dataclass
class TileInfo:
    name: str
    width: int
    height: int    
    rawLength: int
    rawChecksum : int
    compressedLength: int
    compressedBytes: bytes


def RLE8BitEncode(inData):
    # type: (bytes) -> bytes

    
    numBlocks = len(inData)

    rVal = bytearray()

    i = 0
    while i < numBlocks:

        runLength = 1
        
        # determine the run length
        # stop at 255
        currentVal = inData[i]
        while True:
            if  i + runLength >= numBlocks:
                break
            if  currentVal != inData[i+runLength]:
                break
            if runLength >= 255:
                break;
            runLength += 1

        rVal.append(runLength)
        
        rVal.append(currentVal)

        i += runLength
    return rVal

# included for verification
def RLE8BitDecode(inData):
    # type: (bytes) -> bytes

    rVal = bytearray()
    i = 0
    while i < len(inData):
        runLength = inData[i]

        u8 = inData[i+1]
        
        for run in range(runLength):
            rVal.append(u8)

        i += 2
    return bytes(rVal)



def ChecksumDJB2(bytes):
    # type (bytes) -> int

    returnVal = 5381;
    for i in range(len(bytes)):
        returnVal = (returnVal<<5) + returnVal + bytes[i]
        returnVal = returnVal &0xFFFFFFFF

    return returnVal

# Scan the sprite layer and encode it as
# uint16_t: x tile index
# uint16_t: y tile index
# uint16_t: tileID   <-- could be 8, but let's leave it open for special flags?
def SparseEncodeLayer(widthIntiles, heightInTiles, inBytes):
    # type (int, int, bytes) -> int

    outBytes = bytearray()

    idx = 0
    for y in range(heightInTiles):
        for x in range(widthIntiles):

            blockID = inBytes[idx]

            # ignore empty tiles
            if blockID == 0xFF:
                idx += 1
                continue

            print("Found special block {} at {}/{}".format(blockID, x, y))

            # we found something, encode the x, y, id
            xBytes = struct.pack("<H", x)
            yBytes = struct.pack("<H", y)
            idBytes = struct.pack("<H", blockID)

            outBytes.extend(xBytes)
            outBytes.extend(yBytes)
            outBytes.extend(idBytes)

            idx += 1
    return outBytes

def ProcessFile(inPath):
    
    name = os.path.splitext(file)[0]
    headerName = name + ".h"

    print(f"Creating {name}...")

    with open(file, "rb") as inFile:
        rawData = inFile.read()

    # grab the width/height from the header
    
    width = struct.unpack_from("<I", rawData, 0)[0]
    height = struct.unpack_from("<I", rawData, 4)[0]
    print(f"  Width/Height {width}/{height}")
    
    # then slice that away for clarity
    tileData = rawData[8:]

    # the default mappy export script is uint32_t
    # in that case, use this
    # tileData = bytearray(tileData[i] for i in range(0, len(tileData), 4))

    # eeh sorry
    isSpawnLayer = inPath.find("_layer_2") > -1
    
    if isSpawnLayer:

        #
        # Spawn layer, we'll use sparse encodding
        #

        sparseData = SparseEncodeLayer(width, height, tileData)
        sparseSize = len(sparseData)        
        sparseChecksum = ChecksumDJB2(sparseData)

        print(f"  Encoded {sparseSize} sparsely encoded bytes w/ csum: {hex(sparseChecksum)}")

        returnVal = TileInfo(name, width, height, sparseSize, sparseChecksum, sparseSize, sparseData)
        return returnVal

    else:

        #
        # Not a spawn layer, regular tiles
        #
        
        # compress, then validate the compression
        compressedData = RLE8BitEncode(tileData)
        decompressedData = RLE8BitDecode(compressedData)

        sizeBefore = len(tileData)
        sizeAfter = len(decompressedData)
        sizeCompressed = len(compressedData)
        checksumBefore = ChecksumDJB2(tileData)
        checksumAfter = ChecksumDJB2(decompressedData)

        if sizeAfter != sizeBefore:
            raise Exception(f"Compression failed, expected decompressed size of {sizeBefore}, got {sizeAfter}")

        if checksumAfter != checksumBefore:
            raise Exception(f"Compression failed, expected decompressed checksum of {checksumBefore}, got {checksumAfter}")

        print(f"  Compressed {sizeBefore} bytes to {sizeCompressed}, checksum: {hex(checksumAfter)}")

        returnVal = TileInfo(name, width, height, sizeBefore, checksumBefore, sizeCompressed, compressedData)
        return returnVal;

def GenerateHeader(inLayers):

    headerPath = "maps.h"

    #pragma once
    #include <stdio.h>
    #include <stdint.h>

    hSrc = """
// This file is auto-generated by map2h.py and should not be modified manually!

#pragma once
#include <stdio.h>
#include <stdint.h>

typedef struct {
    const char * name;
    const uint32_t index;
    const uint32_t width;   // in tiles
    const uint32_t height;  // in tiles
    const uint32_t rawSize; // in bytes
    const uint32_t rawChecksum;           
    const uint32_t compressedSize;
    const uint8_t* compressedData;
} TileLayer;

"""

    # fix alignment issues
    hSrc += "\n"

    index = 0
    for info in inLayers:

        hSrc += f"const uint8_t _{info.name}_compressed_data[];\n"

        # best break this up for readability        
        hSrc += f"const TileLayer tl_{info.name} = {{ "        
        hSrc += f"\"{info.name}\", "
        hSrc += f"{index}, "
        hSrc += f"{info.width}, "
        hSrc += f"{info.height}, "
        hSrc += f"{info.rawLength}, "
        hSrc += f"{hex(info.rawChecksum)}, "
        hSrc += f"{info.compressedLength}, "
        hSrc += f"_{info.name}_compressed_data, "
        hSrc += f"}};"
        # nice wee space
        hSrc += "\n\n"

        index += 1

    # make a list of all known tile layers
    # so we can unpack them

    hSrc += "\n\n\n"

    hSrc += "/*"
    hSrc += "// force a compile time const without #define\n"
    hSrc += f"enum{{ allTileLayersLength = {len(inLayers)}}};\n"    
    hSrc += "const TileLayer * allTileLayers[] = {\n"
    

    # Generate a little pointer list to make it easier to decompress everything
    for info in inLayers:        
        layerString = "tl_{}".format(info.name)        
        hSrc+= "  &" + layerString + ",\n"

    hSrc += "};"
    hSrc += "\n\n\n"
    hSrc += "*/"

    # then put the actual hex data at the bottom
    for info in inLayers:
                
        hSrc += "const uint8_t _{}_compressed_data[] =".format(info.name)
        hSrc += """{"""
        hSrc += "\n"

        hexVal = ", ".join(f'0x{b:02X}' for b in info.compressedBytes)
        hSrc += hexVal

        hSrc += "\n"
        hSrc += """};"""
        hSrc += "\n"
        hSrc += "\n"

    #and save it to disk
    hFile = open(headerPath, "w")
    hFile.write(hSrc)
    hFile.close()
    print("\nSaved to {}\n".format(headerPath))

allMaps = []

for file in os.listdir("."):
    if file.endswith(".map"):
        info = ProcessFile(file)

        printable = (info.name, info.width, info.height, info.rawLength, hex(info.rawChecksum), info.compressedLength)
        print(f"  Data: {printable}")

        allMaps.append(info)

GenerateHeader(allMaps)




        