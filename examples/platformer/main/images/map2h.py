import os
import struct
from dataclasses import dataclass

@dataclass
class TileInfo:
    name: str
    width: int
    height: int    
    rawLength: int
    rawChecksum : int
    compressedLength: int
    compressedBytes: bytes

def RLE8BitEncode(inData):
    # type: (bytes) -> bytes

    
    numBlocks = len(inData)

    rVal = bytearray()

    i = 0
    while i < numBlocks:

        runLength = 1
        
        # determine the run length
        # stop at 255
        currentVal = inData[i]
        while True:
            if  i + runLength >= numBlocks:
                break
            if  currentVal != inData[i+runLength]:
                break
            if runLength >= 255:
                break;
            runLength += 1

        rVal.append(runLength)
        
        rVal.append(currentVal)

        i += runLength
    return rVal

# included for verification
def RLE8BitDecode(inData):
    # type: (bytes) -> bytes

    rVal = bytearray()
    i = 0
    while i < len(inData):
        runLength = inData[i]

        u8 = inData[i+1]
        
        for run in range(runLength):
            rVal.append(u8)

        i += 2
    return bytes(rVal)



def ChecksumDJB2(bytes):
    # type (bytes) -> int

    returnVal = 5381;
    for i in range(len(bytes)):
        returnVal = (returnVal<<5) + returnVal + bytes[i]
        returnVal = returnVal &0xFFFFFFFF

    return returnVal


def ProcessFile(inPath):
    
    name = os.path.splitext(file)[0]
    headerName = name + ".h"

    print(f"Creating {name}...")

    with open(file, "rb") as inFile:
        rawData = inFile.read()

    # grab the width/height from the header
    
    width = struct.unpack_from("<I", rawData, 0)[0]
    height = struct.unpack_from("<I", rawData, 4)[0]
    print(f"  Width/Height {width}/{height}")
    
    # then slice that away for clarity
    tileData = rawData[8:]

    # the default mappy export script is uint32_t
    # in that case, use this
    # tileData = bytearray(tileData[i] for i in range(0, len(tileData), 4))

    
    # compress, then validate the compression
    compressedData = RLE8BitEncode(tileData)
    decompressedData = RLE8BitDecode(compressedData)

    sizeBefore = len(tileData)
    sizeAfter = len(decompressedData)
    sizeCompressed = len(compressedData)
    checksumBefore = ChecksumDJB2(tileData)
    checksumAfter = ChecksumDJB2(decompressedData)

    if sizeAfter != sizeBefore:
        raise Exception(f"Compression failed, expected decompressed size of {sizeBefore}, got {sizeAfter}")

    if checksumAfter != checksumBefore:
        raise Exception(f"Compression failed, expected decompressed checksum of {checksumBefore}, got {checksumAfter}")

    print(f"  Compressed {sizeBefore} bytes to {sizeCompressed}, checksum: {hex(checksumAfter)}")

    returnVal = TileInfo(name, width, height, sizeBefore, checksumBefore, sizeCompressed, compressedData)
    return returnVal;

def GenerateHeader(inLayers):

    headerPath = "maps.h"

    #pragma once
    #include <stdio.h>
    #include <stdint.h>

    hSrc = """
// This file is auto-generated by map2h.py and should not be modified manually!

#pragma once
#include <stdio.h>
#include <stdint.h>

typedef struct {
    const char * name;
    const uint32_t index;
    const uint32_t width;   // in tiles
    const uint32_t height;  // in tiles
    const uint32_t rawSize; // in bytes
    const uint32_t rawChecksum;           
    const uint32_t compressedSize;
    const uint8_t* compressedData;
} TileLayer;

"""

    # fix alignment issues
    hSrc += "\n"

    index = 0
    for info in inLayers:

        hSrc += f"const uint8_t _{info.name}_compressed_data[];\n"

        # best break this up for readability        
        hSrc += f"const TileLayer tl_{info.name} = {{ "        
        hSrc += f"\"{info.name}\", "
        hSrc += f"{index}, "
        hSrc += f"{info.width}, "
        hSrc += f"{info.height}, "
        hSrc += f"{info.rawLength}, "
        hSrc += f"{hex(info.rawChecksum)}, "
        hSrc += f"{info.compressedLength}, "
        hSrc += f"_{info.name}_compressed_data, "
        hSrc += f"}};"
        # nice wee space
        hSrc += "\n\n"

        index += 1

    # make a list of all known tile layers
    # so we can unpack them

    hSrc += "\n\n\n"

    hSrc += "/*"
    hSrc += "// force a compile time const without #define\n"
    hSrc += f"enum{{ allTileLayersLength = {len(inLayers)}}};\n"    
    hSrc += "const TileLayer * allTileLayers[] = {\n"
    

    # Generate a little pointer list to make it easier to decompress everything
    for info in inLayers:        
        layerString = "tl_{}".format(info.name)        
        hSrc+= "  &" + layerString + ",\n"

    hSrc += "};"
    hSrc += "\n\n\n"
    hSrc += "*/"

    # then put the actual hex data at the bottom
    for info in inLayers:
                
        hSrc += "const uint8_t _{}_compressed_data[] =".format(info.name)
        hSrc += """{"""
        hSrc += "\n"

        hexVal = ", ".join(f'0x{b:02X}' for b in info.compressedBytes)
        hSrc += hexVal

        hSrc += "\n"
        hSrc += """};"""
        hSrc += "\n"
        hSrc += "\n"

    #and save it to disk
    hFile = open(headerPath, "w")
    hFile.write(hSrc)
    hFile.close()
    print("\nSaved to {}\n".format(headerPath))

allMaps = []

for file in os.listdir("."):
    if file.endswith(".map"):
        info = ProcessFile(file)

        printable = (info.name, info.width, info.height, info.rawLength, hex(info.rawChecksum), info.compressedLength)
        print(f"  Data: {printable}")

        allMaps.append(info)

GenerateHeader(allMaps)




        